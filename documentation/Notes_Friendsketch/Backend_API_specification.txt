Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-09-12T17:58:20+02:00

====== Backend API specification ======
Created Tuesday 12 September 2017

====== Summary ======


'''
-- LOBBY --

/lobby
	/index.html : welcome page for connecting to a game

/join
	/:RoomID : redirects to proper join page
	/*/uid : join a room thanks to a join link

-- GAMES --

/games
	/classic : The game in which you draw and other guesses

-- ROOMS --

/rooms
	/create POST json : create a new room and get the room name as return value
	/join POST json : Attempt to join a room, return the game type if successful

-- DECK --

/decks/:lang : Get the list of decks

-- MISC --
/ws : Base url for all websocket endpoints
/ports.js : Shared code for javascript ports.
any: (added to existing path to get relevent resource)
	+/stylesheet.css : Css style
	+/code.js : Generated javascript code
'''



====== Types ======

Specifications of the types used in the API. When a value is specified to be of a certain type, the client must follow it or the request will be refused.

=== Game ===
''Game = "classic"''
The string name of an avaliable game. Any other string will be refused.
* Currently there is only one value possible for it.

=== Name ===
''Name ~= [[::unicode_alphanum::] _-]{2-30}''
A user name. Can be arbitrary unicode alphanumericals.
* No spaces at the start and end.
* This is user-generated and shown to other users!
* Will be refused if the size (in bytes, as opposed to characters) is greater than a certain ammount

=== RoomID ===
''RoomID ~= [A-Z][a-z]+-[A-Z][a-z]*[A-Z]?[a-z]+''
A room id, let identify a unique party going on currently.
* Server-generated. Only values that you got (directly or indirectly) from the server will be accepted,  most likely.

=== ConnId ===
 ''ConnId ~= [A-Za-z0-9]+'' 
A unique Id to connect to a unique websocket assigned per player per room

=== Topic ===
'''
Topic =
'''
	'''
	{ id : TopicId
	, name : String
	, details: String
	}
	'''


The topic for a list of words, it describes the content of the list

=== Deck ===
'''
Deck =
'''
	'''
	{ difficulty : "easy" | "normal" | "hard"
	, topic: Topic | TopicId
	, word_count: Int | nil
	}
	'''

One of the various lists of words available for play.
Note: ''word_count'' will be ignored in requests, while it will always be present in responses from the server.
Similarly, ''topic'' is a ''Topic'' when coming from the server, while it is required to be a ''TopicId'' when sending data to the server

=== Collection ===
'''
Collection =
'''
	'''
	{ decks : [ Deck ]
	, distrs : [ float, float, float ]
	}
	'''


Represents a list of ''Deck''s including the difficulty probability distribution. (Floats: easy, normal, hard)

=== Settings ===
'''
Settings =
	{ round_duration: Int
	, set_count: Int
	, score_scheme: "quadratic" | "linear"
	, collection: Collection
	}

'''
Settings are initialization values for a game

====== Static pages ======

==== Lobby welcome page ====
''GET /lobby/index.html''
Html page. User interface to create a game.

==== Classic mode ====
''GET /games/classic/index.html ''
Html page. User interface for classic game mode

==== Join form ====
 ''GET /join/:RoomID''
Redirects to a page that let you join given '':RoomID''

 ''GET /join/*/uid''
A form that let you submit your username to join a specific room, generated by the server. Only one user can join a game within a single uid

====== Resources ======

===== Decks =====

==== list of decks in given language ====
 ''GET /decks/:lang/'' 
Get all the decks available for the given language. Currently, only ''en'' is accepted for '':lang''.
	* Returns:
		* __200 success__ [Deck] | The list (includes word count and topic id)

===== Rooms =====

==== Create a room ====
''POST /rooms/create Settings''
Create a room for given ''game''.
	* Returns:
		* __201 created__ RoomID | The Body is the RoomID to join.



==== Join a Room ====
''POST /rooms/join {roomid: RoomID, username: Name}''
Attempts to join an existing room ''roomid'' as ''username'' . This will "open" a websocket port at location ''/ws/:ConnId'' that the user can connect to to play the game
	* Returns:
		* __200 success__ ConnId | The ressource for the websocket reserved for the given player.
		* __404 not found__ | ''roomid'' is not a room.
		* __409 conflict__ | ''roomid'' is indeed a room, but ''username'' already taken.
		* __400 bad request__ | ''username'' is not a valid name.

==== Report an error ====
''POST /report plaintext''
Send to server an error report, to log. Note that the log string must not be larger than 2^14 bytes

====== Websockets ======

===== Pintclone =====

==== Types ====
notes:
* list of things between () is represented as a list of fixed size in json
* nullable fields are optional
* **regarding game event sync:** The history is sent in order of the most recent to the oldest in ''sync'' messages.
'''
Point ~= (X, Y) where X = Y = [-2^31; 2^31[ : Int
Score = Int
Color ~= #[0-9a-f]{6}
Size = Float
ChatContent = String

RoundScore
	= { artist: Score}
	| { guessed: Score}
	| { failed: () }
	| { absent: () }
	
RoundState =
	{ drawing: Drawing
	, artist: Name
	, timeout: Int
	, word: WordGuess | nil
	}

Scoreboard = [ (Name, [RoundScore]) ]

Drawing = [ (Point, [ Point ], Color, Size) ]

GameState =
	{ scores: Scoreboard
	, screen: GameScreen
	, history: [ VisibleGameEvent ]
	}

GameScreen
	= { scores: () }
	| { endsummary: (Int, [Name]) }
	| { round: RoundState }
	| { lobby: { master: Name } }

CanvasMsg
	= { start: ( Point, Color, Size ) }
	| { end: () }
	| { continue: Point }

GameReq
	= { canvas: CanvasMsg }
	| { chat: ChatContent }
	| { sync: () }
	| { start: () }

ChatMsg =
	{ content: ChatContent
	, author: Name
	}

WordGuess
	= { artist: String }
	| { guess: Int }

RoundStart =
	{ timeout: Int
	, artist: Name
	, word: WordGuess
	}

VisibleGameEvent
	= { guessed: Name }
	| { left: Name }
	| { joined: Name }
	| { message: ChatMsg }
	| { syncstart: Name }
	| { syncover: String }
	| { synccomplete: () }
	| { voted: Name }

HiddenGameEvent
	= { correct: String }
	| { timeoutsync: Int }
	| { sync: GameState }
	| { mastery: () }
	| { over: (String, [ (Name, RoundScore) ]) }
	| { start: RoundStart }
	| { reveal: (Int, Char) }
	| { complete: (Int, Scoreboard) }

GameMsg
	= { canvas: CanvasMsg }
	| { event: VisibleGameEvent | HiddenGameEvent }
'''


==== Websockets ====
''GET /ws/:ConnId''
Connect to the websocket assigned to '':ConnId'' . You get a ''ConnId'' by ''POST'' ing on the ''/rooms/join'' ressource.
	* Accepts: GameReq
	* Sends: GameMsg
