Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-09-26T18:05:55+02:00

====== Roadblocks & current issues ======
Created Tuesday 26 September 2017

====== REST API ======


* The frontend still needs to handle the rejection more gracefully when trying to connect to a room where they are not expected

====== Game design ======

They say it is particularly hard to design a multiplayer game. And they are right!
Here are the troubles I'm currently having:
* My current design is based around formally specifying the game as a series of connected state machines. And relying on the server as the single source of truth in order to properly handle distributed shared game state.
* This is not inherently terrible (especially since my client is written in a functional language) as long as I keep track of my specs.
	But this might get more complex with time and I may make basic mistakes in the design of the state machines.
	Or if I fail to implement the server specs correctly (I guess that identifies the backend as a good test target)

* State machines are weak to specify a distributed system, in fact, they only describe the state of a single client based on "commands" (which would be arcs in the graph) that the server sends them. This causes formal verification issues.

====== Server Game API ======

Difficult to split the game logic in two: (actual game logic vs. player/session management)

Already have a convinient elm-like reactive system ''fn oversee'' . We however, need to separate pure game logic from communication logic.

* Communication logic **requires** an up-to-date list of the partecipants of the game, so we need to pass that as an argument, instead of keeping track of them in the game state.
* Game needs to be able to handle partecipant quitting and joining. Wouldn't want to accept a connection to someone that is not accepted in the game, so game needs to be able to refuse on connection and ask for disconnection.
* Manage better copying/usernames:
	* Should the game need to handle the user Id's? What about overhead copying names? Can this be worked around with ''Rc''?
		* → Game should be able to access player names.
* Merge handling of players in ''GameInternal'' and ''GameRoom''
	* GameRoom.game == GameInternal.client_chan

problem:
	- sharing state information between GameInternal and GameRoom
	- GameInternal is a single value that is folded over by a channel
		- Any other mean to communicate with GameInternal is ripe for 
		  race conditions (in fact, GameInternal is single-threaded)
	- WS has access to game receiv_chan

	- How to give feedback through channel?
		→ Game logic (needs to process request) is in GameInternals, while
		   the server must respond.
		 + Closing a room when no one remains
		→ possible: feedback channel (is it?)
	- Separating game logic from comm logic
	  - GameInternal::join can become GameRoom::join
	- Necessary to associate Player to Connection in GameInternal?
	
Solution:
	* First separate game logic from connection logic in ''oversee''
	* Handle all connection logic in ''oversee'' (instead of GameManager)
	* Use a channel to send feedback in case a connection must be handled

==== Game specification ====
ideal goal: having Room management logic in ''ConnectionManager'' and game logic in ''Game'' .

Problem: difficulty separating game logic from room management logic.
	* Already-defined data structures do not separate them. 
	* Changing API is high friction, because I coupled the API data structures with the code.
Potential solution: Use wrappers in client API file, so as to be able to change API, without having to change client code








